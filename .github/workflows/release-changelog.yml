name: Generate Release Changelog

on:
  release:
    types: [created]

permissions:
  contents: write

jobs:
  changelog:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog generation
          
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Get previous release tag
        id: prev_tag
        run: |
          # Get all tags sorted by version
          TAGS=$(git tag -l --sort=-version:refname)
          
          # Get the current tag
          CURRENT_TAG="${{ github.event.release.tag_name }}"
          
          # Find the previous tag
          PREV_TAG=""
          FOUND_CURRENT=false
          for tag in $TAGS; do
            if [ "$FOUND_CURRENT" = true ]; then
              PREV_TAG=$tag
              break
            fi
            if [ "$tag" = "$CURRENT_TAG" ]; then
              FOUND_CURRENT=true
            fi
          done
          
          # If no previous tag found, use the first commit
          if [ -z "$PREV_TAG" ]; then
            PREV_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          
          echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "Previous tag: $PREV_TAG"
          
      - name: Generate changelog
        id: changelog
        run: |
          PREV_TAG="${{ steps.prev_tag.outputs.previous_tag }}"
          CURRENT_TAG="${{ github.event.release.tag_name }}"
          
          # Start changelog
          echo "## What's Changed" > changelog.md
          echo "" >> changelog.md
          
          # Get all commits between tags
          COMMITS=$(git log $PREV_TAG..$CURRENT_TAG --pretty=format:"%h %s" --reverse)
          
          # Initialize categories
          FEATURES=""
          FIXES=""
          DOCS=""
          CHORES=""
          OTHER=""
          
          # Parse commits by conventional commit format
          while IFS= read -r commit; do
            HASH=$(echo "$commit" | awk '{print $1}')
            MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
            
            # Create commit link
            COMMIT_LINK="[\`$HASH\`](https://github.com/${{ github.repository }}/commit/$HASH)"
            
            if [[ "$MESSAGE" =~ ^feat(\(.*\))?:\ .* ]]; then
              FEATURES="${FEATURES}- ${MESSAGE} ${COMMIT_LINK}\n"
            elif [[ "$MESSAGE" =~ ^fix(\(.*\))?:\ .* ]]; then
              FIXES="${FIXES}- ${MESSAGE} ${COMMIT_LINK}\n"
            elif [[ "$MESSAGE" =~ ^docs(\(.*\))?:\ .* ]]; then
              DOCS="${DOCS}- ${MESSAGE} ${COMMIT_LINK}\n"
            elif [[ "$MESSAGE" =~ ^(chore|ci|build|test|style|refactor|perf)(\(.*\))?:\ .* ]]; then
              CHORES="${CHORES}- ${MESSAGE} ${COMMIT_LINK}\n"
            else
              OTHER="${OTHER}- ${MESSAGE} ${COMMIT_LINK}\n"
            fi
          done <<< "$COMMITS"
          
          # Write categories to changelog
          if [ -n "$FEATURES" ]; then
            echo "### 🚀 Features" >> changelog.md
            echo -e "$FEATURES" >> changelog.md
          fi
          
          if [ -n "$FIXES" ]; then
            echo "### 🐛 Bug Fixes" >> changelog.md
            echo -e "$FIXES" >> changelog.md
          fi
          
          if [ -n "$DOCS" ]; then
            echo "### 📚 Documentation" >> changelog.md
            echo -e "$DOCS" >> changelog.md
          fi
          
          if [ -n "$CHORES" ]; then
            echo "### 🔧 Maintenance" >> changelog.md
            echo -e "$CHORES" >> changelog.md
          fi
          
          if [ -n "$OTHER" ]; then
            echo "### 📝 Other Changes" >> changelog.md
            echo -e "$OTHER" >> changelog.md
          fi
          
          # Add contributors section
          echo "" >> changelog.md
          echo "### 👥 Contributors" >> changelog.md
          echo "" >> changelog.md
          
          # Use associative arrays to track contributors
          declare -A GITHUB_USERS
          declare -A AUTHOR_NAMES
          
          # Get unique commit SHAs for this release
          COMMITS=$(git log $PREV_TAG..$CURRENT_TAG --pretty=format:"%H")
          
          # For each commit, try to get GitHub username
          for commit in $COMMITS; do
            # Get commit info from GitHub API
            COMMIT_INFO=$(curl -s -H "Authorization: token ${{ github.token }}" \
              "https://api.github.com/repos/${{ github.repository }}/commits/$commit")
            
            # Extract author email, login, and name
            AUTHOR_EMAIL=$(echo "$COMMIT_INFO" | jq -r '.commit.author.email // empty')
            AUTHOR_LOGIN=$(echo "$COMMIT_INFO" | jq -r '.author.login // empty')
            AUTHOR_NAME=$(echo "$COMMIT_INFO" | jq -r '.commit.author.name // empty')
            
            # Store GitHub username if available
            if [ -n "$AUTHOR_LOGIN" ] && [ -n "$AUTHOR_EMAIL" ]; then
              GITHUB_USERS[$AUTHOR_EMAIL]="@$AUTHOR_LOGIN"
            elif [ -n "$AUTHOR_NAME" ] && [ -n "$AUTHOR_EMAIL" ]; then
              # Only store author name if we don't have a GitHub username for this email
              if [ -z "${GITHUB_USERS[$AUTHOR_EMAIL]}" ]; then
                AUTHOR_NAMES[$AUTHOR_EMAIL]="$AUTHOR_NAME"
              fi
            fi
          done
          
          # Collect and sort all contributors
          {
            # Output GitHub users
            for email in "${!GITHUB_USERS[@]}"; do
              echo "- ${GITHUB_USERS[$email]}"
            done
            
            # Output author names only if no GitHub username exists for that email
            for email in "${!AUTHOR_NAMES[@]}"; do
              if [ -z "${GITHUB_USERS[$email]}" ]; then
                echo "- ${AUTHOR_NAMES[$email]}"
              fi
            done
          } | sort -u >> changelog.md
          
          # Add full changelog link
          echo "" >> changelog.md
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_TAG...$CURRENT_TAG" >> changelog.md
          
          # Output the changelog
          cat changelog.md
          
      - name: Update release with changelog
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.release.tag_name }}
          body_path: changelog.md
          append_body: false  # Replace the body instead of appending