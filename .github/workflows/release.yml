name: Release Workflow

on:
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  # Generate changelog and update release notes
  changelog:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Get previous release tag
        id: previous_tag
        run: |
          # Get the previous release tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT
          
      - name: Generate changelog content
        id: changelog
        run: |
          # Generate changelog between previous tag and current tag
          PREV_TAG="${{ steps.previous_tag.outputs.tag }}"
          CURRENT_TAG="${{ github.event.release.tag_name }}"
          
          # Create the changelog
          {
            echo "## What's Changed in $CURRENT_TAG"
            echo ""
            
            # Get commit messages grouped by type
            echo "### üöÄ Features"
            git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s ([%h](https://github.com/${{ github.repository }}/commit/%H))" --grep="^feat" || echo "- No new features"
            echo ""
            
            echo "### üêõ Bug Fixes"
            git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s ([%h](https://github.com/${{ github.repository }}/commit/%H))" --grep="^fix" || echo "- No bug fixes"
            echo ""
            
            echo "### üîß Maintenance & Other Changes"
            git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s ([%h](https://github.com/${{ github.repository }}/commit/%H))" --grep="^(chore|docs|style|refactor|perf|test|build|ci)" || echo "- No maintenance changes"
            echo ""
            
            # Add Docker images section
            echo "## üê≥ Docker Images"
            echo ""
            echo "Pull the latest image:"
            echo '```bash'
            echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CURRENT_TAG"
            echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
            echo '```'
            echo ""
            echo "Run with Docker Compose:"
            echo '```bash'
            echo "# Production deployment"
            echo "docker-compose -f docker-compose.prod.yml up -d"
            echo ""
            echo "# Development deployment"
            echo "docker-compose up -d"
            echo '```'
            echo ""
            
            # Add quick start section
            echo "## üöÄ Quick Start"
            echo ""
            echo '```bash'
            echo "# Create your .env file"
            echo "cp .env.example .env"
            echo ""
            echo "# Edit your configuration"
            echo "nano .env"
            echo ""
            echo "# Run the scheduler"
            echo "docker run -d \\"
            echo "  --name coinbase-scheduler \\"
            echo "  --env-file .env \\"
            echo "  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CURRENT_TAG"
            echo '```'
            echo ""
            
            # Add contributors
            echo "## üë• Contributors"
            echo ""
            
            # Use associative arrays to track contributors
            declare -A GITHUB_USERS
            declare -A AUTHOR_NAMES
            
            # Get unique commit SHAs
            COMMITS=$(git log $PREV_TAG..$CURRENT_TAG --pretty=format:"%H")
            
            # For each commit, get the GitHub username using API
            for commit in $COMMITS; do
              # Get commit info from GitHub API
              COMMIT_INFO=$(curl -s -H "Authorization: token ${{ github.token }}" \
                "https://api.github.com/repos/${{ github.repository }}/commits/$commit")
              
              # Extract author email, login, and name
              AUTHOR_EMAIL=$(echo "$COMMIT_INFO" | jq -r '.commit.author.email // empty')
              AUTHOR_LOGIN=$(echo "$COMMIT_INFO" | jq -r '.author.login // empty')
              AUTHOR_NAME=$(echo "$COMMIT_INFO" | jq -r '.commit.author.name // empty')
              
              # Store GitHub username if available
              if [ -n "$AUTHOR_LOGIN" ] && [ -n "$AUTHOR_EMAIL" ]; then
                GITHUB_USERS[$AUTHOR_EMAIL]="@$AUTHOR_LOGIN"
              elif [ -n "$AUTHOR_NAME" ] && [ -n "$AUTHOR_EMAIL" ]; then
                # Only store author name if we don't have a GitHub username for this email
                if [ -z "${GITHUB_USERS[$AUTHOR_EMAIL]}" ]; then
                  AUTHOR_NAMES[$AUTHOR_EMAIL]="$AUTHOR_NAME"
                fi
              fi
            done
            
            # Collect all contributors and sort them
            {
              # Output GitHub users
              for email in "${!GITHUB_USERS[@]}"; do
                echo "- ${GITHUB_USERS[$email]}"
              done
              
              # Output author names only if no GitHub username exists for that email
              for email in "${!AUTHOR_NAMES[@]}"; do
                if [ -z "${GITHUB_USERS[$email]}" ]; then
                  echo "- ${AUTHOR_NAMES[$email]}"
                fi
              done
            } | sort -u
            
            echo ""
            echo ""
            
            # Add full changelog link
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_TAG...$CURRENT_TAG"
            
          } > release-notes.md
          
          # Show the generated notes for debugging
          cat release-notes.md
          
      - name: Update release description
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.release.tag_name }}
          body_path: release-notes.md
          
      - name: Create or Update CHANGELOG.md
        run: |
          # Check if CHANGELOG.md exists
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Create a temporary file with the new entry
          {
            echo "## [${{ github.event.release.tag_name }}] - $(date +%Y-%m-%d)"
            echo ""
            cat release-notes.md | sed 's/## What'\''s Changed in .*//'
            echo ""
            echo "---"
            echo ""
          } > new-entry.md
          
          # Prepend the new entry to CHANGELOG.md (after the header)
          head -n 4 CHANGELOG.md > temp-changelog.md
          cat new-entry.md >> temp-changelog.md
          tail -n +5 CHANGELOG.md >> temp-changelog.md
          mv temp-changelog.md CHANGELOG.md
          
      - name: Create Pull Request for CHANGELOG
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: main
          commit-message: "docs: update CHANGELOG.md for ${{ github.event.release.tag_name }}"
          title: "üìù Update CHANGELOG for ${{ github.event.release.tag_name }}"
          body: |
            This PR updates the CHANGELOG.md with the latest release notes for ${{ github.event.release.tag_name }}.
            
            ### Changes
            - Added changelog entry for ${{ github.event.release.tag_name }}
            - Updated with commit history since last release
            
            Auto-generated by the release workflow.
          branch: changelog-update-${{ github.event.release.tag_name }}
          delete-branch: true
          labels: |
            documentation
            automated